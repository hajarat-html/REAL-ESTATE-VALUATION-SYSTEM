# Data Cleaning & Manipulation libraries
import pandas as pd
import numpy as np
import io
import os
import joblib

# Data App library
import streamlit as st
from streamlit_option_menu import option_menu
from streamlit_extras.chart_container import chart_container # Keeping this import as it might be useful for future enhancements

# Machine Learning models library
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression, Ridge, Lasso
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.neighbors import KNeighborsRegressor
from sklearn.svm import SVR
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline

# Data Visualization library
import plotly.express as px
import plotly.graph_objects as go
import folium
from streamlit_folium import folium_static

# --- Page Configuration ---
page_title = "Real Estate Price Evaluation System"
page_icon = "üè†"
layout = "centered"

st.set_page_config(page_title=page_title, page_icon=page_icon, layout=layout)

# --- Custom CSS for Enhanced Aesthetics ---
st.markdown("""
<style>
    /* General body styling */
    body {
        font-family: 'Inter', sans-serif;
        background-color: #f0f2f6; /* Light gray background */
    }

    /* Adjust Streamlit's main content area padding to account for the fixed header */
    .main .block-container {
        padding-top: 4rem; /* CORRECTED: Reduced padding to bring content closer */
        padding-right: 1rem;
        padding-left: 1rem;
        padding-bottom: 2rem;
    }

    /* Target the main title's container div (Streamlit's internal header div) */
    div[data-testid="stHeader"] {
        background-image: linear-gradient(to right, #4a00e0, #8e2de2); /* Blue-purple gradient */
        padding: 1rem;
        color: white; /* For any text directly in this div */
        border-bottom-left-radius: 15px;
        border-bottom-right-radius: 15px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        display: flex; /* Use flexbox to center content */
        justify-content: center; /* Center horizontally */
        align-items: center; /* Center vertically */
        width: 100%;
        position: fixed; /* Make it stick to the top */
        top: 0;
        left: 0;
        z-index: 999; /* Ensure it's above other content */
    }

    /* Target the h1 element generated by st.title() inside that header */
    div[data-testid="stHeader"] h1 {
        color: white !important; /* Force white color */
        font-size: 3rem !important; /* Made it much bigger */
        font-weight: bold;
        text-align: center !important; /* Force center alignment for text */
        margin: 0; /* Remove default margins */
        padding: 0;
    }

    /* Sidebar Navigation Styling */
    .sidebar .sidebar-content {
        background-color: #f8f9fa; /* Lighter sidebar background */
        border-right: 1px solid #e0e0e0;
        padding-top: 2rem;
    }
    .st-emotion-cache-1pxazr7 { /* Target the option_menu container */
        padding-top: 1rem;
    }
    .st-emotion-cache-1pxazr7 button { /* General button styling */
        background-color: rgba(0, 0, 0, 0); /* Transparent background */
        color: #333; /* Darker text for contrast */
        border-radius: 0.5rem;
        margin-bottom: 0.5rem;
        font-weight: 500;
        transition: all 0.2s ease-in-out;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        border: none; /* No default border */
        width: 100%; /* Full width for buttons */
    }
    .st-emotion-cache-1pxazr7 button:hover {
        background-color: rgba(74, 0, 224, 0.1); /* Light blue-purple on hover */
        color: #4a00e0; /* Darker blue-purple text */
    }
    .st-emotion-cache-1pxazr7 button.selected {
        background-color: #4a00e0; /* Solid blue-purple for active */
        color: white;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
    }
    .st-emotion-cache-1pxazr7 button.selected .icon {
        color: white !important; /* Ensure icon is white when selected */
    }

    /* Card-like structures for content sections */
    .st-emotion-cache-zt5ig8 { /* Target st.container and similar blocks */
        background-color: white;
        padding: 1.5rem;
        border-radius: 1rem;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        margin-bottom: 1.5rem;
        border: 1px solid #e0e0e0; /* Subtle border */
    }

    /* Home Page Hero Section */
    .hero-section {
        position: relative;
        height: 400px; /* Adjust height as needed */
        background-image: url('https://placehold.co/1200x400/8e2de2/ffffff?text=Your+Real+Estate+Hero+Image'); /* Placeholder image */
        background-size: cover;
        background-position: center;
        border-radius: 1rem;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        color: white;
        margin-bottom: 2rem; /* This also adds space below the hero section */
    }
    .hero-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(to right, rgba(74, 0, 224, 0.7), rgba(142, 45, 226, 0.7)); /* Blue-purple overlay */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 2rem;
    }
    .hero-title {
        font-size: 3.5rem;
        font-weight: 800;
        margin-bottom: 1rem;
        line-height: 1.2;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    .hero-title u {
        text-decoration-color: #ffcc00; /* Yellow underline */
        text-underline-offset: 8px;
        text-decoration-thickness: 4px;
    }
    .hero-subtitle {
        font-size: 1.3rem;
        max-width: 800px;
        margin-bottom: 2rem;
        line-height: 1.5;
        text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
    }

    /* CTA Buttons */
    .cta-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.8rem 1.8rem;
        border-radius: 0.75rem;
        font-weight: 600;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.2s ease-in-out;
        text-decoration: none; /* Remove underline for links */
    }
    .cta-primary {
        background-color: #ff8c00; /* Orange */
        color: white;
        border: none;
        box-shadow: 0 4px 8px rgba(255, 140, 0, 0.4);
    }
    .cta-primary:hover {
        background-color: #ff6a00; /* Darker orange */
        box-shadow: 0 6px 12px rgba(255, 140, 0, 0.6);
        transform: translateY(-2px);
    }
    .cta-secondary {
        background-color: rgba(255, 255, 255, 0.2); /* Transparent white */
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.5);
        margin-left: 1rem;
    }
    .cta-secondary:hover {
        background-color: rgba(255, 255, 255, 0.3);
        border-color: white;
    }
    .cta-button .icon {
        margin-left: 0.5rem;
        font-size: 1.2em;
    }

    /* Contact Agent Box */
    .contact-agent-box {
        background-color: rgba(0, 0, 0, 0.3); /* Slightly transparent background */
        border-radius: 0.75rem;
        color: #fff;
        box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        text-align: left;
        border: 1px solid rgba(255,255,255,0.3);
        padding: 1.5rem;
        margin-top: 2rem;
        max-width: 400px;
        width: 100%;
        backdrop-filter: blur(5px); /* Frosted glass effect */
    }
    .contact-agent-box h3 {
        font-size: 1.5rem;
        font-weight: 700;
        margin-bottom: 1rem;
    }
    .contact-agent-box p {
        font-size: 0.95rem;
        margin-bottom: 0.5rem;
        color: #e0e7ff; /* Lighter text color */
    }
    .contact-agent-box .stButton > button {
        width: 100%;
        margin-top: 1rem;
        background-color: #6a0dad; /* Purple for register button */
        color: white;
        border-radius: 0.5rem;
        padding: 0.75rem 1rem;
        border: none;
        transition: background-color 0.2s;
    }
    .contact-agent-box .stButton > button:hover {
        background-color: #5a0ca0; /* Darker purple */
    }

    /* System Status */
    .system-status {
        display: flex;
        justify-content: space-around;
        align-items: center;
        background-color: #f8f9fa;
        padding: 1.5rem;
        border-radius: 1rem;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        margin-top: 2rem;
    }
    .status-item {
        text-align: center;
        font-weight: 600;
        color: #333;
    }
    .status-item .value {
        font-size: 1.8rem;
        color: #4a00e0;
        margin-bottom: 0.3rem;
    }
    .status-item .label {
        font-size: 0.9rem;
        color: #555;
    }

    /* Input field styling */
    .st-emotion-cache-1c5c70q { /* General Streamlit input labels */
        font-weight: 600;
        color: #4a00e0; /* Blue-purple label */
    }
    .st-emotion-cache-vdgyx6 { /* Number input */
        border-radius: 0.5rem;
        border: 1px solid #ced4da;
    }
    .st-emotion-cache-16idsys { /* Selectbox */
        border-radius: 0.5rem;
        border: 1px solid #ced4da;
    }

    /* Predict button */
    .stButton button {
        background-color: #4a00e0; /* Blue-purple */
        color: white;
        border-radius: 0.75rem;
        padding: 0.75rem 1.5rem;
        font-size: 1.1rem;
        font-weight: 600;
        border: none;
        box_shadow: 0 4px 8px rgba(74, 0, 224, 0.4);
        transition: all 0.2s ease-in-out;
    }
    .stButton button:hover {
        background-color: #5a0ca0; /* Darker blue-purple */
        box-shadow: 0 6px 12px rgba(74, 0, 224, 0.6);
        transform: translateY(-2px);
    }
    .stButton button:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(74, 0, 224, 0.3);
    }

    /* Success/Info/Warning boxes */
    .stAlert {
        border-radius: 0.75rem;
    }
    .stAlert.stAlert--success {
        background-color: #d4edda;
        color: #155724;
        border-left: 5px solid #28a745;
    }
    .stAlert.stAlert--info {
        background-color: #d1ecf1;
        color: #0c5460;
        border-left: 5px solid #17a2b8;
    }
    .stAlert.stAlert--warning {
        background-color: #fff3cd;
        color: #856404;
        border-left: 5px solid #ffc107;
    }

    /* Footer styling */
    .footer {
        font-size: 0.85rem;
        color: #888;
        text-align: center;
        margin-top: 3rem;
        padding-top: 1rem;
        border-top: 1px solid #eee;
    }
</style>
""", unsafe_allow_html=True)


# --- File Paths ---
DATA_PATH = 'nigeria_houses_data.csv'
SYNTHETIC_DATA_PATH = 'synthetic_real_estate_dataset.csv' # New dataset
MODEL_PATH = 'house_price_model_pipeline.pkl' # Updated model path

# --- Global Variables for data and model (cached to avoid reloading) ---
@st.cache_data
def load_data(file_path):
    """Loads the dataset."""
    if os.path.exists(file_path):
        return pd.read_csv(file_path)
    return None

@st.cache_resource
def load_model(path):
    """Loads a pre-trained machine learning model."""
    if os.path.exists(path):
        try:
            return joblib.load(path)
        except Exception as e:
            st.error(f"Error loading model: {e}")
            return None
    return None

@st.cache_resource
def save_model(_model, path):
    """Saves the trained machine learning model."""
    try:
        joblib.dump(_model, path)
        return True
    except Exception as e:
        st.error(f"Error saving model: {e}")
        return False

# Load datasets
df_legacy = load_data(DATA_PATH)
df_synthetic = load_data(SYNTHETIC_DATA_PATH)

# Use synthetic data as primary if available, else fallback
df = df_synthetic if df_synthetic is not None else df_legacy

if df is None:
    st.error("üö® Error: Dataset not found. Please ensure 'synthetic_real_estate_dataset.csv' or 'nigeria_houses_data.csv' is in the same directory.")
    st.stop() # Stop the app if data is not loaded

# Preprocessing for prediction page: Identify numerical and categorical features
# This part runs once when the script starts
if df is not None:
    # Features for the prediction model based on 'synthetic_real_estate_dataset.csv'
    numerical_features_raw = ['Bedrooms', 'Bathrooms', 'Size_sqft', 'Year_Built',
                          'Proximity_to_CityCenter_km', 'Nearby_Schools', 'Crime_Rate',
                          'Economic_Growth_Index', 'Market_Demand', 'Distance_to_Public_Transport_km',
                          'Monthly_Rent', 'Latitude', 'Longitude']
    categorical_features_raw = ['Location', 'Property_Type', 'Condition', 'Infrastructure_Quality',
                            'Flood_Risk', 'Security_Level']
    target_feature = 'Sale_Price'

    # Map raw names from synthetic dataset to internal names used in model training/prediction
    # This is crucial for consistency.
    feature_mapping = {
        'Sale_Price': 'price',
        'Bedrooms': 'bedrooms',
        'Bathrooms': 'bathrooms',
        'Property_Type': 'title',
        'Location': 'location_name'
    }

    # Reverse mapping for display purposes if needed
    reverse_feature_mapping = {v: k for k, v in feature_mapping.items()}


    # Update dataframe columns to internal names for consistent use in the app
    df_mapped = df.rename(columns=feature_mapping).copy()

    # Engineer 'total_rooms' here for general use across pages if it's not already present
    if 'total_rooms' not in df_mapped.columns and 'bedrooms' in df_mapped.columns and 'bathrooms' in df_mapped.columns:
        df_mapped['total_rooms'] = df_mapped['bedrooms'] + df_mapped['bathrooms']
    
    # Define features to be used by the model training and prediction, using internal names
    numerical_features_for_model = [
        'bedrooms', 'bathrooms', 'Size_sqft', 'Year_Built',
        'Proximity_to_CityCenter_km', 'Nearby_Schools', 'Crime_Rate',
        'Economic_Growth_Index', 'Market_Demand', 'Distance_to_Public_Transport_km',
        'Monthly_Rent'
    ]
    categorical_features_for_model = [
        'location_name', 'title', 'Condition', 'Infrastructure_Quality',
        'Flood_Risk', 'Security_Level'
    ]

    # Add 'total_rooms' to numerical features if it's engineered
    if 'total_rooms' in df_mapped.columns and 'total_rooms' not in numerical_features_for_model:
        numerical_features_for_model.append('total_rooms')

    # Ensure actual columns exist in the mapped dataframe
    numerical_features_for_model = [col for col in numerical_features_for_model if col in df_mapped.columns]
    categorical_features_for_model = [col for col in categorical_features_for_model if col in df_mapped.columns]

    # Combine all features for the model
    features_for_model_pipeline = numerical_features_for_model + categorical_features_for_model
    target_feature_for_model = 'price' # Internal name for target

    # Store df_mapped in session state so all pages use the same preprocessed data
    st.session_state['df_processed'] = df_mapped
else:
    # Fallback if df is None
    st.session_state['df_processed'] = pd.DataFrame()
    features_for_model_pipeline = []
    target_feature_for_model = ''


# --- Model Training Function (for Model Performance page) ---
@st.cache_resource(hash_funcs={pd.DataFrame: lambda _: None}) # Add hash_funcs to prevent hashing issues with large dataframes
def train_model(data_df, model_type, numerical_cols, categorical_cols, target_col):
    if data_df.empty:
        st.warning("No data available for training.")
        return None, None, None, None, None, None

    # Drop rows with NaN in critical columns required for model training
    # This uses the internal names after mapping
    required_cols = numerical_cols + categorical_cols + [target_col]
    data_for_training = data_df.dropna(subset=[col for col in required_cols if col in data_df.columns]).copy()

    if data_for_training.empty:
        st.warning("Data is empty after dropping NaNs for training. Cannot train model.")
        return None, None, None, None, None, None

    # Filter features to only include those present in the *current* training dataframe
    actual_numerical_cols = [f for f in numerical_cols if f in data_for_training.columns]
    actual_categorical_cols = [f for f in categorical_cols if f in data_for_training.columns]

    # Define features (X) and target (y)
    X = data_for_training[actual_numerical_cols + actual_categorical_cols]
    y = data_for_training[target_col]

    if X.empty or y.empty:
        st.warning("Features or target are empty after preprocessing for training.")
        return None, None, None, None, None, None

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Preprocessing pipelines for numerical and categorical features
    numeric_transformer = Pipeline(steps=[
        ('scaler', StandardScaler())
    ])
    categorical_transformer = Pipeline(steps=[
        ('onehot', OneHotEncoder(handle_unknown='ignore'))
    ])

    # Create a preprocessor using ColumnTransformer
    preprocessor = ColumnTransformer(
        transformers=[
            ('num', numeric_transformer, actual_numerical_cols),
            ('cat', categorical_transformer, actual_categorical_cols)
        ],
        remainder='passthrough' # Keep other columns if any, though not expected here
    )

    # Define the base model
    if model_type == "Linear Regression":
        base_model = LinearRegression()
    elif model_type == "Random Forest":
        base_model = RandomForestRegressor(random_state=42)
    elif model_type == "Decision Tree":
        base_model = DecisionTreeRegressor(random_state=42)
    elif model_type == "Ridge Regression":
        base_model = Ridge(random_state=42)
    elif model_type == "Lasso Regression":
        base_model = Lasso(random_state=42)
    elif model_type == "Gradient Boosting":
        base_model = GradientBoostingRegressor(random_state=42)
    elif model_type == "K-Nearest Neighbors":
        base_model = KNeighborsRegressor()
    elif model_type == "Support Vector Regressor":
        base_model = SVR()
    else:
        st.error("Selected model type is not supported.")
        return None, None, None, None, None, None

    # Create the full pipeline
    full_pipeline = Pipeline(steps=[('preprocessor', preprocessor),
                                    ('regressor', base_model)])

    st.info(f"Training {model_type} model...")
    full_pipeline.fit(X_train, y_train)
    st.success(f"{model_type} model trained successfully!")

    y_pred = full_pipeline.predict(X_test)

    # Evaluate the model
    mae = mean_absolute_error(y_test, y_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))
    r2 = r2_score(y_test, y_pred)

    # Return the pipeline and test data for plotting
    return full_pipeline, mae, rmse, r2, (y_test, y_pred), actual_numerical_cols + actual_categorical_cols


# --- Main Application ---
# The st.title() call creates the primary title that we are styling
st.title(page_title + " " + page_icon)

# Sidebar Navigation
with st.sidebar:
    selected = option_menu(
        menu_title="Main Menu",
        options=["Home", "Dataset", "Model", "Prediction", "Geospatial Analysis", "Data Exploration"], # Updated options
        icons=["house-door", "table", "cpu-fill", "currency-dollar", "geo-alt", "search"], # Updated icons
        menu_icon="cast",
        default_index=0,
        styles={
            "container": {"padding": "0!important", "background-color": "#f8f9fa", "margin-top": "1rem"},
            "icon": {"color": "gray", "font-size": "20px"},
            "nav-link": {"font-size": "16px", "text-align": "left", "margin": "0px", "--hover-color": "#e9ecef"},
            "nav-link-selected": {"background-color": "#4a00e0", "color": "white", "font-weight": "bold"},
        }
    )

st.write("#") # Add some vertical space

# Access the preprocessed data from session state
data = st.session_state.get('df_processed', pd.DataFrame())

# --- Page Content based on selection ---

# Home Page
if selected == "Home":
    st.markdown("""
        <div class="hero-section">
            <div class="hero-overlay">
                <h1 class="hero-title">FIND YOUR <u style="color:white;">PERFECT HOME</u></h1>
                <p class="hero-subtitle">Discover your ideal property with our intelligent valuation system. Access precise price estimations, visualize market trends, and explore properties geographically.</p>
                <div style="display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center;">
                    <a href="#" onclick="window.parent.document.querySelector('.st-emotion-cache-1pxazr7 button[data-testid=\'stOptionMenu-Prediction\']').click(); return false;" class="cta-button cta-primary">
                        GET PRICE PREDICTION <span class="icon">‚ûú</span>
                    </a>
                </div>
            </div>
        </div>
        """, unsafe_allow_html=True)

    st.markdown("""
        <div class="system-status">
            <div class="status-item">
                <div class="value">2500+</div>
                <div class="label">Properties Listed</div>
            </div>
            <div class="status-item">
                <div class="value">98%</div>
                <div class="label">Valuation Accuracy</div>
            </div>
            <div class="status-item">
                <div class="value">‚≠ê 4.9</div>
                <div class="label">User Rating</div>
            </div>
        </div>
        """, unsafe_allow_html=True)

    st.write("---")
    st.markdown("### Our Mission")
    st.write("Our mission is to provide data-driven insights into the Nigerian real estate market. We aim to simplify the property search and valuation process, making informed decisions accessible to everyone.")

    st.markdown("### How It Works")
    st.write("1. **Train Models:** Select from various machine learning models and train them on our data to find the best fit.")
    st.write("2. **Predict Price:** Input your desired property specifications and get an instant, accurate price prediction.")
    st.write("3. **Explore Data:** Review detailed dataset information and geospatial insights.")

# Dataset Page (Now includes visualizations)
elif selected == "Dataset":
    st.header("Data Overview & Exploration")
    st.info("Explore the synthetic real estate dataset through raw data, statistics, interactive filters, and key visualizations.")

    if not data.empty:
        st.subheader("Raw Data Preview")
        st.write("First 5 rows of the dataset:")
        st.dataframe(data.head())
        st.markdown("---")

        st.subheader("Data Information")
        st.write("Detailed information about columns, non-null values, and data types:")
        buffer = io.StringIO()
        data.info(buf=buffer)
        st.text(buffer.getvalue())
        st.markdown("---")

        st.subheader("Descriptive Statistics")
        st.write("Summary statistics for numerical columns:")
        st.dataframe(data.describe())
        st.markdown("---")

        st.subheader("Interactive Filters")
        min_price = int(data['price'].min())
        max_price = int(data['price'].max())

        price_filter = st.slider('Select Price Range (‚Ç¶)', min_price, max_price, (min_price, max_price))

        bedrooms_filter_val = st.slider('Select Number of Bedrooms', int(data['bedrooms'].min()), int(data['bedrooms'].max()), (int(data['bedrooms'].min()), int(data['bedrooms'].max())))
        bathrooms_filter_val = st.slider('Select Number of Bathrooms', int(data['bathrooms'].min()), int(data['bathrooms'].max()), (int(data['bathrooms'].min()), int(data['bathrooms'].max())))
        size_sqft_filter_val = st.slider('Select Size (sqft)', int(data['Size_sqft'].min()), int(data['Size_sqft'].max()), (int(data['Size_sqft'].min()), int(data['Size_sqft'].max())))
        year_built_filter_val = st.slider('Select Year Built', int(data['Year_Built'].min()), int(data['Year_Built'].max()), (int(data['Year_Built'].min()), int(data['Year_Built'].max())))

        location_filter = st.multiselect('Select Location(s)', data['location_name'].unique().tolist(), data['location_name'].unique().tolist())
        property_type_filter = st.multiselect('Select Property Type(s)', data['title'].unique().tolist(), data['title'].unique().tolist())

        filtered_data = data[
            (data['price'] >= price_filter[0]) & (data['price'] <= price_filter[1]) &
            (data['bedrooms'] >= bedrooms_filter_val[0]) & (data['bedrooms'] <= bedrooms_filter_val[1]) &
            (data['bathrooms'] >= bathrooms_filter_val[0]) & (data['bathrooms'] <= bathrooms_filter_val[1]) &
            (data['Size_sqft'] >= size_sqft_filter_val[0]) & (data['Size_sqft'] <= size_sqft_filter_val[1]) &
            (data['Year_Built'] >= year_built_filter_val[0]) & (data['Year_Built'] <= year_built_filter_val[1]) &
            (data['location_name'].isin(location_filter)) &
            (data['title'].isin(property_type_filter))
        ]
        st.write(f"Displaying {len(filtered_data)} filtered data points:")
        st.dataframe(filtered_data)
        st.markdown("---")

        # --- Visualizations for Dataset Page ---
        st.subheader("Key Data Visualizations")

        # Distribution of House Prices
        with st.expander("Distribution of House Prices"):
            st.info("This plot shows the distribution of house prices in the dataset. It helps to understand the overall price range and frequency of different price points.")
            fig_hist = px.histogram(data, x='price', nbins=50, title='Distribution of House Prices',
                                    color_discrete_sequence=['#1f77b4'])
            fig_hist.update_layout(bargap=0.2, xaxis_title='Price (‚Ç¶)', yaxis_title='Count', template='plotly_dark')
            st.plotly_chart(fig_hist, use_container_width=True)
        st.markdown("---")

        # House Prices by Size_sqft
        with st.expander("House Prices by Size (sqft)"):
            st.info("This scatter plot shows the relationship between house prices and the property size in square feet.")
            fig_size = px.scatter(data, x='Size_sqft', y='price', color='location_name',
                                  title='House Price vs. Size (sqft)',
                                  labels={'Size_sqft': 'Size (sqft)', 'price': 'Price (‚Ç¶)'},
                                  hover_data=['title', 'bedrooms', 'bathrooms'])
            st.plotly_chart(fig_size, use_container_width=True)
        st.markdown("---")

        # House Type (title) vs. Price (Box Plot)
        with st.expander("House Price by Property Type"):
            st.info("This box plot shows how house prices vary by the type of property. It helps to identify any patterns or outliers.")
            fig_house_type = px.box(data, x='title', y='price', color='location_name',
                                    title='House Price Distribution by Property Type',
                                    labels={'title': 'Property Type', 'price': 'Price (‚Ç¶)'})
            st.plotly_chart(fig_house_type, use_container_width=True)
        st.markdown("---")


    else:
        st.warning("No data available for data exploration. Please ensure your dataset is correctly loaded.")

# Model Page
elif selected == "Model":
    st.header("Train and Evaluate Machine Learning Models")
    st.write("## Select a model and train it to predict property prices.")

    if not data.empty:
        # Features for the model, using internal names from df_mapped
        numerical_features_model_page = numerical_features_for_model
        categorical_features_model_page = categorical_features_for_model
        target_model_page = target_feature_for_model

        # Check if selected features are present in the data for immediate UI feedback
        if not all(f in data.columns for f in numerical_features_model_page + categorical_features_model_page):
            st.error("Some selected features are not present in the dataset. Please check your data and feature list.")
            st.stop()

        st.sidebar.subheader("Model Selection")
        model_choice = st.sidebar.selectbox("Select Model", ["Linear Regression", "Ridge Regression", "Lasso Regression",
                                                             "Decision Tree", "Random Forest", "Gradient Boosting",
                                                             "K-Nearest Neighbors", "Support Vector Regressor"])

        if st.button(f"Train {model_choice} Model"):
            with st.spinner(f"Training the {model_choice} model, please wait..."):
                trained_model_pipeline, mae, rmse, r2, y_test_y_pred_tuple, trained_features = train_model(
                    data, model_choice, numerical_features_model_page, categorical_features_model_page, target_model_page
                )

                if trained_model_pipeline:
                    # Display metrics
                    st.subheader("Model Evaluation Metrics")
                    col_mae, col_rmse, col_r2 = st.columns(3)
                    col_mae.metric("Mean Absolute Error (MAE)", f"{mae:,.2f}")
                    col_rmse.metric("Root Mean Squared Error (RMSE)", f"{rmse:,.2f}")
                    col_r2.metric("R-squared (R¬≤)", f"{r2:.4f}")

                    # Save the trained pipeline
                    if save_model(trained_model_pipeline, MODEL_PATH):
                        st.success(f"Trained {model_choice} model saved successfully to '{MODEL_PATH}'!")
                        st.session_state['trained_model_pipeline'] = trained_model_pipeline
                        st.session_state['features_for_model'] = trained_features
                    else:
                        st.error("Failed to save the model.")

                    st.markdown("---")
                    st.write("#")

                    # Visualization using Plotly: Actual vs. Predicted House Prices
                    if y_test_y_pred_tuple:
                        y_test, y_pred = y_test_y_pred_tuple
                        st.write("### Actual vs. Predicted Property Prices")
                        results_df = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred})

                        fig = go.Figure()
                        fig.add_trace(go.Scatter(
                            x=results_df['Actual'],
                            y=results_df['Predicted'],
                            mode='markers',
                            name='Predicted vs. Actual',
                            marker=dict(color='yellow', size=6, line=dict(width=1))
                        ))
                        fig.add_trace(go.Scatter(
                            x=results_df['Actual'],
                            y=results_df['Actual'],
                            mode='lines',
                            name='Perfect Prediction',
                            line=dict(color='red', dash='dash')
                        ))

                        fig.update_layout(
                            title=f"{model_choice} - Actual vs Predicted Prices",
                            xaxis_title="Actual Prices (‚Ç¶)",
                            yaxis_title="Predicted Prices (‚Ç¶)",
                            showlegend=True,
                            legend=dict(x=0, y=1)
                        )
                        st.plotly_chart(fig, use_container_width=True)
                else:
                    st.error("Model training failed. Please check your data and configuration.")
        else:
            st.info("Click 'Train Model' to train the selected model.")
            st.warning("Training a model can take some time depending on the dataset size and model complexity.")
            # Attempt to load and display metrics of a previously saved model if available
            current_model = load_model(MODEL_PATH)
            if current_model:
                st.subheader("Previously Trained Model (if available)")
                st.info(f"A model from '{MODEL_PATH}' is loaded. To see its metrics, you would need to re-run the training process or ensure metrics are saved alongside the model (which is not implemented for loading here).")
    else:
        st.warning("No data available for model training. Please check the data loading process.")


# Prediction Page
elif selected == "Prediction":
    st.header("Predict Property Prices üí∞")
    st.write("Enter the features of the property to get a predicted price.")

    # Load the trained model pipeline (if available)
    model_pipeline = None
    features_for_model = None # To store features used during training

    if 'trained_model_pipeline' in st.session_state and 'features_for_model' in st.session_state:
        model_pipeline = st.session_state['trained_model_pipeline']
        features_for_model = st.session_state['features_for_model']
        st.success("Model pipeline loaded from session state!")
    elif os.path.exists(MODEL_PATH):
        try:
            model_pipeline = joblib.load(MODEL_PATH)
            # When loading from file, reconstruct features_for_model based on the training logic
            # Using the `features_for_model_pipeline` global variable as the source of truth
            features_for_model = features_for_model_pipeline
            st.session_state['features_for_model'] = features_for_model
            st.success("Model pipeline loaded from file!")
        except Exception as e:
            st.error(f"Error loading model pipeline from file: {e}. Please train a model on the 'Model' page first.")
    else:
        st.warning("No trained model pipeline found. Please train a model on the 'Model' page first.")

    st.markdown("---")
    st.write("### Input Features for Prediction")

    if not data.empty and features_for_model:
        # Get min/max/unique for input widgets from the loaded data (df_mapped from session state)
        col1, col2, col3 = st.columns(3)

        with col1:
            input_bedrooms = st.number_input("Number of Bedrooms", min_value=int(data['bedrooms'].min()), max_value=int(data['bedrooms'].max()), value=int(data['bedrooms'].mean()))
            input_bathrooms = st.number_input("Number of Bathrooms", min_value=int(data['bathrooms'].min()), max_value=int(data['bathrooms'].max()), value=int(data['bathrooms'].mean()))
            input_size_sqft = st.number_input("Size (sqft)", min_value=int(data['Size_sqft'].min()), max_value=int(data['Size_sqft'].max()), value=int(data['Size_sqft'].mean()))
            input_year_built = st.slider("Year Built", min_value=int(data['Year_Built'].min()), max_value=int(data['Year_Built'].max()), value=int(data['Year_Built'].mean()))

        with col2:
            input_proximity_to_city_center_km = st.slider("Proximity to City Center (km)", min_value=float(data['Proximity_to_CityCenter_km'].min()), max_value=float(data['Proximity_to_CityCenter_km'].max()), value=float(data['Proximity_to_CityCenter_km'].mean()))
            input_nearby_schools = st.slider("Nearby Schools", min_value=int(data['Nearby_Schools'].min()), max_value=int(data['Nearby_Schools'].max()), value=int(data['Nearby_Schools'].mean()))
            input_crime_rate = st.slider("Crime Rate", min_value=float(data['Crime_Rate'].min()), max_value=float(data['Crime_Rate'].max()), value=float(data['Crime_Rate'].mean()))
            input_economic_growth_index = st.slider("Economic Growth Index", min_value=float(data['Economic_Growth_Index'].min()), max_value=float(data['Economic_Growth_Index'].max()), value=float(data['Economic_Growth_Index'].mean()))

        with col3:
            input_distance_to_public_transport_km = st.slider("Distance to Public Transport (km)", min_value=float(data['Distance_to_Public_Transport_km'].min()), max_value=float(data['Distance_to_Public_Transport_km'].max()), value=float(data['Distance_to_Public_Transport_km'].mean()))
            input_monthly_rent = st.number_input("Monthly Rent (‚Ç¶)", min_value=int(data['Monthly_Rent'].min()), max_value=int(data['Monthly_Rent'].max()), value=int(data['Monthly_Rent'].mean()))

        # Categorical inputs
        st.markdown("---")
        st.subheader("Categorical Features")
        cat_col1, cat_col2, cat_col3 = st.columns(3)
        with cat_col1:
            input_location_name = st.selectbox("Location", data['location_name'].unique().tolist())
            input_property_type = st.selectbox("Property Type", data['title'].unique().tolist())
        with cat_col2:
            input_condition = st.selectbox("Condition", data['Condition'].unique().tolist())
            input_infrastructure_quality = st.selectbox("Infrastructure Quality", data['Infrastructure_Quality'].unique().tolist())
        with cat_col3:
            input_flood_risk = st.selectbox("Flood Risk", data['Flood_Risk'].unique().tolist())
            input_security_level = st.selectbox("Security Level", data['Security_Level'].unique().tolist())
            input_market_demand = st.selectbox("Market Demand", data['Market_Demand'].unique().tolist())

        # total_rooms is now bedrooms + bathrooms (this will be engineered as part of the pipeline if the model expects it)
        # For display, we can show it:
        displayed_total_rooms = input_bedrooms + input_bathrooms
        st.info(f"Calculated Total Rooms (Bedrooms + Bathrooms): {displayed_total_rooms}")


        st.markdown("---")
        st.write("#")
        st.markdown("### Input Summary")
        # Displaying all inputs in a summary
        cols_summary = st.columns(3)
        cols_summary[0].metric("Bedrooms", input_bedrooms)
        cols_summary[0].metric("Bathrooms", input_bathrooms)
        cols_summary[0].metric("Size (sqft)", input_size_sqft)
        cols_summary[0].metric("Year Built", input_year_built)
        cols_summary[1].metric("Proximity to City Center (km)", f"{input_proximity_to_city_center_km:.2f}")
        cols_summary[1].metric("Nearby Schools", input_nearby_schools)
        cols_summary[1].metric("Crime Rate", f"{input_crime_rate:.2f}")
        cols_summary[1].metric("Economic Growth Index", f"{input_economic_growth_index:.2f}")
        cols_summary[2].metric("Distance to Public Transport (km)", f"{input_distance_to_public_transport_km:.2f}")
        cols_summary[2].metric("Monthly Rent (‚Ç¶)", f"{input_monthly_rent:,.2f}")
        st.markdown("---")
        st.write("### Categorical Input Summary")
        cat_cols_summary = st.columns(3)
        cat_cols_summary[0].write(f"**Location:** {input_location_name}")
        cat_cols_summary[0].write(f"**Property Type:** {input_property_type}")
        cat_cols_summary[1].write(f"**Condition:** {input_condition}")
        cat_cols_summary[1].write(f"**Infrastructure Quality:** {input_infrastructure_quality}")
        cat_cols_summary[2].write(f"**Flood Risk:** {input_flood_risk}")
        cat_cols_summary[2].write(f"**Security Level:** {input_security_level}")
        cat_cols_summary[2].write(f"**Market Demand:** {input_market_demand}")


        # Create a DataFrame for prediction, ensuring columns match features_for_model and original order
        # Ensure column names here match the internal names expected by the model pipeline
        input_data_for_prediction = {
            'bedrooms': input_bedrooms,
            'bathrooms': input_bathrooms,
            'Size_sqft': input_size_sqft,
            'Year_Built': input_year_built,
            'Proximity_to_CityCenter_km': input_proximity_to_city_center_km,
            'Nearby_Schools': input_nearby_schools,
            'Crime_Rate': input_crime_rate,
            'Economic_Growth_Index': input_economic_growth_index,
            'Distance_to_Public_Transport_km': input_distance_to_public_transport_km,
            'Monthly_Rent': input_monthly_rent,
            'location_name': input_location_name, # Internal name
            'title': input_property_type, # Internal name
            'Condition': input_condition,
            'Infrastructure_Quality': input_infrastructure_quality,
            'Flood_Risk': input_flood_risk,
            'Security_Level': input_security_level,
            'Market_Demand': input_market_demand
        }
        # Add engineered feature 'total_rooms' if the model expects it
        if 'total_rooms' in features_for_model:
            input_data_for_prediction['total_rooms'] = input_bedrooms + input_bathrooms

        # Create a single-row DataFrame from the input dictionary
        input_df = pd.DataFrame([input_data_for_prediction])

        # Ensure the columns are in the same order as trained features_for_model
        # This is crucial for the preprocessor to work correctly
        input_df = input_df[features_for_model]


        if st.button("Predict Price"):
            if model_pipeline and features_for_model:
                st.info("Predicting the property price based on your input...")
                try:
                    prediction = model_pipeline.predict(input_df)
                    st.success(f"The predicted price of the property is approximately ‚Ç¶{prediction[0]:,.2f}")

                    st.download_button(
                        label="Download Prediction Result",
                        data=f"Predicted Price: ‚Ç¶{prediction[0]:,.2f}\n"
                             f"Input Details:\n{input_df.T.to_string()}",
                        file_name="house_price_prediction.txt",
                        mime="text/plain"
                    )

                except Exception as e:
                    st.error(f"An error occurred during prediction. This might be due to the model not being trained on all necessary features or an input mismatch: {e}")
                    st.warning("Please ensure the model is trained correctly and all inputs are valid for the selected model.")
            else:
                st.warning("No model is available for prediction. Please train one on the 'Model' page.")
    else:
        st.warning("No data available to define prediction input ranges, or model features are missing. Please check the 'Dataset' and 'Model' pages.")


# Geospatial Analysis page
elif selected == "Geospatial Analysis":
    st.header("Geospatial Analysis")
    st.write("## Analyzing House Prices by Location")
    st.info("This section provides insights into property price variations across different locations in your synthetic dataset.")

    if not data.empty and 'Latitude' in data.columns and 'Longitude' in data.columns and 'location_name' in data.columns:
        st.subheader("Property Locations on Map")
        st.info("This map visualizes the distribution of properties. The size of the marker indicates the property size, and the color indicates its price.")

        # Create a base map
        map_center = [data['Latitude'].mean(), data['Longitude'].mean()]
        m = folium.Map(location=map_center, zoom_start=6)

        # Add points to the map
        for idx, row in data.iterrows():
            folium.CircleMarker(
                location=[row['Latitude'], row['Longitude']],
                radius=row['Size_sqft'] / data['Size_sqft'].max() * 15 + 5, # Scale radius by size
                popup=f"Price: ‚Ç¶{row['price']:,.2f}<br>Location: {row['location_name']}<br>Size: {row['Size_sqft']} sqft",
                color='blue',
                fill=True,
                fill_color='blue',
                fill_opacity=0.6
            ).add_to(m)
        folium_static(m)
        st.markdown("---")

        # Average Price by Location
        st.subheader("Average Property Price by Location")
        avg_price_location = data.groupby('location_name')['price'].mean().reset_index().sort_values(by='price', ascending=False)
        fig_location_price_geo = px.bar(avg_price_location, x='location_name', y='price',
                                     title='Average Property Price by Location (‚Ç¶)',
                                     labels={'location_name': 'Location', 'price': 'Average Price (‚Ç¶)'},
                                     color='price', color_continuous_scale=px.colors.sequential.Viridis)
        st.plotly_chart(fig_location_price_geo, use_container_width=True)
        st.markdown("---")
    else:
        st.warning("No data available for geospatial analysis or missing 'Latitude'/'Longitude' columns. Please check the 'Dataset' page.")


# Data Exploration page
elif selected == "Data Exploration":
    st.header("Data Exploration")
    st.info("Explore the dataset with interactive visualizations to understand distributions and relationships between key features.")

    if not data.empty:
        # Scatter Matrix of Key Numerical Features
        st.subheader("Scatter Matrix of Key Features")
        # Updated columns for scatter matrix
        explore_cols = ['price', 'bedrooms', 'bathrooms', 'Size_sqft', 'total_rooms',
                        'Monthly_Rent', 'Year_Built', 'Proximity_to_CityCenter_km', 'Nearby_Schools',
                        'Crime_Rate', 'Economic_Growth_Index', 'Distance_to_Public_Transport_km']
        # Filter for only columns present in the dataframe
        explore_cols_present = [col for col in explore_cols if col in data.columns]

        fig_explore = px.scatter_matrix(data[explore_cols_present], dimensions=explore_cols_present,
                                        title='Scatter Matrix of Key Housing Features',
                                        color='price',
                                        color_continuous_scale=px.colors.sequential.Plasma)
        fig_explore.update_layout(height=1000, width=1000) # Increased size for more features
        st.plotly_chart(fig_explore, use_container_width=True)
        st.markdown("---")

        st.write("### Model Comparison (Placeholder)")
        st.info("This section will compare different models' performances. The actual model training and evaluation is done on the 'Model' page.")
        st.write("Please navigate to the 'Model' page to train and evaluate machine learning models.")
        st.markdown("---")
    else:
        st.warning("No data available for data exploration. Please check the 'Dataset' page.")


# --- Footer ---
st.sidebar.markdown("""
---
**Developed by ADESHIGBIN OYINDAMOLA AJARAT FTP/CSC/24/0090164**
""")

st.markdown("""
    <div class="footer">
        <p>&copy; 2025 Real Estate Price Evaluation System. All rights reserved.</p>
    </div>
    """, unsafe_allow_html=True)

